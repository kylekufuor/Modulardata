# Design: Plan Mode & Smart Profiling

**Status:** Approved
**Date:** January 2026

---

## Overview

This document captures key design decisions for ModularData's conversational data transformation system.

---

## 1. Plan Mode (Default Behavior)

### Concept

By default, the AI operates in **Plan Mode** where transformations are accumulated into a plan before execution. This gives users visibility and control over what changes will be made.

### Flow

```
User: "Clean up this data"
            â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  PLAN MODE                                           â”‚
â”‚                                                      â”‚
â”‚  Current Plan:                                       â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚ 1. Trim whitespace in all columns              â”‚  â”‚
â”‚  â”‚ 2. Remove 45 duplicate rows                    â”‚  â”‚
â”‚  â”‚ 3. Fill null emails with "unknown@na.com"      â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚                                                      â”‚
â”‚  ðŸ’¡ "I've planned 3 transformations.                 â”‚
â”‚      Ready to apply? Or add more changes first?"     â”‚
â”‚                                                      â”‚
â”‚  [Apply Now]  [Add More]  [Apply One-by-One]         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Rules

| Rule | Description |
|------|-------------|
| Default threshold | **3 transformations** per node (best practice) |
| Soft limit | AI *suggests* applying at 3, doesn't force |
| User override | Can add more (4, 5, 10+) before applying |
| Granular mode | Can apply one-by-one (1 transformation = 1 node) |
| No hard limit | User has full control over batching |

### User Actions

| Action | Result |
|--------|--------|
| "Apply" / "Do it" | Execute all planned transformations â†’ Create 1 node |
| "Add more" / Keep chatting | Continue accumulating transformations |
| "Apply one at a time" | Each transformation creates its own node |
| "Clear plan" / "Start over" | Discard current plan |
| "Show plan" | Display current accumulated transformations |

### Why 3 Transformations?

- Small enough to review and understand
- Meaningful progress per node
- Creates natural "undo checkpoints"
- Balances granularity vs. efficiency

---

## 2. Header Row Detection

### Problem

Real-world CSVs often have:
- Metadata rows before the actual header (report title, date generated, etc.)
- The actual column headers on row 2, 3, or beyond

### Solution

The profiler will scan the first N rows to detect the most likely header row.

### Detection Heuristics

| Signal | Weight | Description |
|--------|--------|-------------|
| Unique string values | High | Headers are typically unique text |
| No nulls | Medium | Header row usually has all columns filled |
| Different from data pattern | High | Headers don't look like data values |
| Consistent data types below | High | Rows after header have consistent types |

### Profile Output

```python
class DataProfile(BaseModel):
    # ... existing fields ...

    # Header detection
    detected_header_row: int = 0          # Which row contains headers
    header_confidence: float = 1.0        # 0.0-1.0 confidence score
    skipped_rows: int = 0                 # Rows before header (metadata)

    # User can override
    user_header_row: int | None = None    # User-specified override
```

### User Override

User can adjust via chat:
- "The header is on row 3"
- "Skip the first 2 rows"
- "Row 0 is actually data, there's no header"

---

## 3. Footer/Data End Detection

### Problem

CSVs from Excel exports often have:
- Summary rows at the bottom ("Total: 1,234")
- Empty rows after data
- Metadata at the end ("Generated by SAP on 2024-01-15")

### Solution

Lightweight detection of obvious footer patterns.

### Detection Heuristics

| Pattern | Action |
|---------|--------|
| Rows where >50% columns are empty | Flag as potential footer |
| Rows with aggregate keywords (Total, Sum, Average, Count) | Flag as summary row |
| Rows after 2+ consecutive empty rows | Consider data ended |

### Profile Output

```python
class DataProfile(BaseModel):
    # ... existing fields ...

    # Footer detection
    detected_data_end_row: int | None = None   # Last row of actual data
    detected_footer_rows: int = 0              # Number of footer rows
    footer_type: str | None = None             # "summary", "metadata", "empty"
```

---

## 4. Data Model Updates

### SessionPlan Model

Tracks accumulated transformations before execution:

```python
class TransformationStep(BaseModel):
    """Single transformation in a plan."""
    step_number: int
    transformation_type: TransformationType
    target_columns: list[ColumnTarget]
    parameters: dict[str, Any]
    explanation: str                    # Human-readable description
    estimated_rows_affected: int | None # Preview of impact

class SessionPlan(BaseModel):
    """Accumulated plan for a session (Plan Mode)."""
    session_id: str
    steps: list[TransformationStep]
    created_at: datetime
    updated_at: datetime

    # Status
    status: Literal["planning", "ready", "applied", "cancelled"]

    # Thresholds
    suggest_apply_at: int = 3           # Suggest applying at N steps

    def should_suggest_apply(self) -> bool:
        """Return True if we've hit the suggestion threshold."""
        return len(self.steps) >= self.suggest_apply_at

    def add_step(self, step: TransformationStep) -> None:
        """Add a transformation step to the plan."""
        step.step_number = len(self.steps) + 1
        self.steps.append(step)
        self.updated_at = datetime.utcnow()
```

### Database Schema Addition

```sql
-- New table: session_plans (tracks plans before execution)
CREATE TABLE session_plans (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    session_id UUID REFERENCES sessions(id) ON DELETE CASCADE,
    steps JSONB NOT NULL DEFAULT '[]',
    status TEXT NOT NULL DEFAULT 'planning',
    suggest_apply_at INTEGER NOT NULL DEFAULT 3,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Index for quick lookups
CREATE INDEX idx_session_plans_session_id ON session_plans(session_id);
```

---

## 5. API Endpoints (Milestone 7)

### Chat Endpoint (Plan Mode)

```
POST /api/v1/sessions/{session_id}/chat
{
    "message": "remove rows where email is null"
}

Response:
{
    "type": "plan_updated",
    "plan": {
        "session_id": "...",
        "steps": [
            {
                "step_number": 1,
                "transformation_type": "drop_rows",
                "explanation": "Remove rows where email is null",
                "estimated_rows_affected": 45
            }
        ],
        "status": "planning",
        "suggestion": null
    },
    "message": "Added to plan: Remove rows where email is null (affects ~45 rows)"
}
```

### After 3 Steps

```
Response:
{
    "type": "plan_updated",
    "plan": { ... 3 steps ... },
    "suggestion": {
        "message": "You have 3 transformations planned. Ready to apply them?",
        "options": ["apply", "add_more", "apply_one_by_one", "show_plan"]
    }
}
```

### Apply Plan

```
POST /api/v1/sessions/{session_id}/plan/apply
{
    "mode": "all"  // or "one_by_one" or "steps": [1, 2]
}

Response:
{
    "type": "plan_applied",
    "node_id": "new-node-uuid",
    "transformations_applied": 3,
    "rows_before": 1000,
    "rows_after": 955,
    "message": "Applied 3 transformations. Created checkpoint."
}
```

---

## 6. Implementation Priority

| Phase | Feature | Milestone |
|-------|---------|-----------|
| 1 | Header row detection in profiler | Pre-M7 |
| 2 | Footer detection in profiler | Pre-M7 |
| 3 | SessionPlan model & storage | M7 |
| 4 | Plan Mode chat flow | M7 |
| 5 | Apply plan endpoint | M7 |

---

## 7. Future Enhancements

- **Plan templates**: Save common transformation sequences
- **Plan suggestions**: AI suggests next steps based on data issues
- **Collaborative plans**: Multiple users can add to same plan
- **Plan history**: View and re-apply previous plans
